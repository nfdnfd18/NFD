import React, { useState, useEffect, useRef } from 'react';
import { useAuth } from '../../NFDcomponents/AuthContext.nfd';
import apiRequest from '../../NFDLib/apiRequest.js';
import UploadWidget from '../../NFDcomponents/UploadWidget.nfd';
import './MyProfile.scss';

function MyProfile() {
  const { currentUser, login, logout, updateUser } = useAuth() || {};
  const [user, setUser] = useState(currentUser || null);
  const [editing, setEditing] = useState(false);
  const [loading, setLoading] = useState(false);
  const [avatarUploading, setAvatarUploading] = useState(false);
  const [headerUploading, setHeaderUploading] = useState(false);
  const [toast, setToast] = useState({ show: false, message: '', type: 'info' });

  // show preview while editing (default ON). When saved we render view-only (editing=false)
  const [showPreviewDuringEdit, setShowPreviewDuringEdit] = useState(true);

  // Cloudinary config (hardcoded, same as in UploadWidget)
  const CLOUD_NAME = "dqbezy7ge";
  const UPLOAD_PRESET = "4authnfd";

  // Header editor states
  const fileInputRef = useRef(null);
  const [headerEditOpen, setHeaderEditOpen] = useState(false);
  const [headerEditSrc, setHeaderEditSrc] = useState(null); // dataURL of selected file
  const [editScale, setEditScale] = useState(1);
  const [editPos, setEditPos] = useState({ x: 0, y: 0 });
  const [dragStart, setDragStart] = useState(null);
  const editImageRef = useRef(null);
  const editorStageRef = useRef(null); // <-- new ref for fit calculation

  // header export dimensions - wider aspect ratio to preserve more of the image
  const HEADER_W = 1200;
  const HEADER_H = 400;

  useEffect(() => {
    setUser(currentUser || null);
  }, [currentUser]);

  if (!user) {
    return (
      <div className="profile-shell empty">
        <div className="profile-card">
          <h3>No user</h3>
          <p>Please login to view profile.</p>
        </div>
      </div>
    );
  }

  const handleChange = (field) => (e) => {
    setUser(prev => ({ ...prev, [field]: e.target.value }));
  };

  async function uploadToCloudinary(file) {
    if (!CLOUD_NAME || !UPLOAD_PRESET) {
      throw new Error('Cloudinary not configured (VITE_CLOUDINARY_CLOUD_NAME / VITE_CLOUDINARY_UPLOAD_PRESET).');
    }
    const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/image/upload`;
    const fd = new FormData();
    fd.append('file', file);
    fd.append('upload_preset', UPLOAD_PRESET);
    // Optionally set folder or context by adding more fields
    const resp = await fetch(url, { method: 'POST', body: fd });
    if (!resp.ok) {
      const txt = await resp.text().catch(() => '');
      throw new Error(`Upload failed: ${resp.status} ${txt}`);
    }
    const data = await resp.json();
    return data.secure_url || data.url;
  }

  // Persist uploaded image immediately and update auth store so changes survive refresh
  const onAvatarWidgetState = async (uploadedUrl) => {
    if (!uploadedUrl) {
      setToast({ show: true, message: 'Avatar upload failed', type: 'error' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
      return;
    }
    const url = Array.isArray(uploadedUrl) ? uploadedUrl[0] : uploadedUrl;
    setAvatarUploading(true);
    try {
      const resp = await apiRequest.put(`/users/${user.id}`, { avatar: url }, { withCredentials: true });
      const newUser = resp?.data || { ...user, avatar: url };
      setUser(newUser);
      try { if (typeof updateUser === 'function') updateUser(newUser); } catch (e) {}
      setToast({ show: true, message: 'Avatar saved', type: 'success' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
    } catch (err) {
      console.error('Failed to save avatar', err);
      setToast({ show: true, message: 'Failed to save avatar', type: 'error' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
    } finally {
      setAvatarUploading(false);
    }
  };

  const onHeaderWidgetState = async (uploadedUrl) => {
    if (!uploadedUrl) {
      setToast({ show: true, message: 'Header upload failed', type: 'error' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
      return;
    }
    const url = Array.isArray(uploadedUrl) ? uploadedUrl[0] : uploadedUrl;
    setHeaderUploading(true);
    try {
      const resp = await apiRequest.put(`/users/${user.id}`, { headerImage: url }, { withCredentials: true });
      const newUser = resp?.data || { ...user, headerImage: url };
      setUser(newUser);
      try { if (typeof updateUser === 'function') updateUser(newUser); } catch (e) {}
      setToast({ show: true, message: 'Header saved', type: 'success' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
    } catch (err) {
      console.error('Failed to save header', err);
      setToast({ show: true, message: 'Failed to save header', type: 'error' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
    } finally {
      setHeaderUploading(false);
    }
  };

  const handleSave = async () => {
    setLoading(true);
    try {
      const id = user.id;
      const payload = {
        username: user.username,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        avatar: user.avatar,
        headerImage: user.headerImage,
        bio: user.bio,
      };

      const resp = await apiRequest.put(`/users/${id}`, payload, { withCredentials: true });

      if (resp && resp.data) {
        try { login(resp.data, localStorage.getItem('Love_wins_Whats_up_with_that')); } catch(e){}
        setUser(resp.data);
      } else {
        setUser(prev => ({ ...prev, ...payload }));
      }

      setToast({ show: true, message: 'Profile saved', type: 'success' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);

      // after save switch to view-only (no inputs). preview is the view.
      setEditing(false);
      setShowPreviewDuringEdit(false);
    } catch (err) {
      console.error('Save profile failed', err);
      setToast({ show: true, message: 'Failed to save profile', type: 'error' });
      setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
      alert('Failed to save profile: ' + (err?.response?.data?.error || err.message || err));
    } finally {
      setLoading(false);
    }
  };

  const handleCancel = () => {
    setUser(currentUser);
    setEditing(false);
  };

  // Small render helper: preview card (used during edit and view)
  const ProfilePreview = ({ u }) => (
    <section className="profile-card preview-card" aria-hidden={!u}>
      <div className="card-head">
        <h3>{u?.firstName || u?.username || 'Profile'}</h3>
      </div>
      <div className="preview-body">
        <div className="preview-row">
          <strong>
            <span className="field-icon" aria-hidden="true">üë§</span>
            <span className="label-text">Username</span>
          </strong>
          <span className="value-text">{u?.username}</span>
        </div>

        <div className="preview-row">
          <strong>
            <span className="field-icon" aria-hidden="true">‚úâÔ∏è</span>
            <span className="label-text">Email</span>
          </strong>
          <span className="value-text">{u?.email}</span>
        </div>

        <div className="preview-row">
          <strong>
            <span className="field-icon" aria-hidden="true">üßë</span>
            <span className="label-text">Name</span>
          </strong>
          <span className="value-text">{[u?.firstName, u?.lastName].filter(Boolean).join(' ')}</span>
        </div>

        <div className="preview-row">
          <strong>
            <span className="field-icon" aria-hidden="true">üìû</span>
            <span className="label-text">Phone</span>
          </strong>
          <span className="value-text">{u?.phone}</span>
        </div>

        <div className="preview-row full">
          <strong>
            <span className="field-icon" aria-hidden="true">üí¨</span>
            <span className="label-text">Bio</span>
          </strong>
          <span className="value-text">{u?.bio}</span>
        </div>
      </div>
    </section>
  );

  // handle local header file selection
  const onHeaderFileSelect = async (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => {
      setHeaderEditSrc(reader.result);
      setEditScale(1);
      setEditPos({ x: 0, y: 0 });
      setHeaderEditOpen(true);
    };
    reader.readAsDataURL(f);
    e.target.value = '';
  };

  // drag handlers for panning
  const onEditPointerDown = (ev) => {
    ev.preventDefault();
    const start = getPointerPos(ev);
    setDragStart(start);
  };
  const onEditPointerMove = (ev) => {
    if (!dragStart) return;
    const p = getPointerPos(ev);
    setEditPos(prev => ({ x: prev.x + (p.x - dragStart.x), y: prev.y + (p.y - dragStart.y) }));
    setDragStart(p);
  };
  const onEditPointerUp = () => setDragStart(null);
  const getPointerPos = (ev) => {
    if (ev.touches && ev.touches[0]) return { x: ev.touches[0].clientX, y: ev.touches[0].clientY };
    return { x: ev.clientX, y: ev.clientY };
  };

  // create canvas crop from current transform and upload
  const saveEditedHeader = async () => {
    if (!headerEditSrc) return setHeaderEditOpen(false);
    const img = editImageRef.current;
    if (!img) return setHeaderEditOpen(false);

    // Use exact cover export dimensions so saved header has predictable size
    const outW = HEADER_W;
    const outH = HEADER_H;

    // compute displayed image size under current scale
    const dispW = img.naturalWidth * editScale;
    const dispH = img.naturalHeight * editScale;

    // center of container coordinates
    const cx = outW / 2;
    const cy = outH / 2;

    // top-left of image in container
    const imgLeft = cx - dispW / 2 + editPos.x;
    const imgTop = cy - dispH / 2 + editPos.y;

    const canvas = document.createElement('canvas');
    canvas.width = outW;
    canvas.height = outH;
    const ctx = canvas.getContext('2d');
    // fill transparent black then draw
    ctx.fillStyle = '#000000';
    ctx.fillRect(0,0,outW,outH);

    // draw image at computed position and scale
    const tmp = new Image();
    tmp.crossOrigin = 'anonymous';
    tmp.src = headerEditSrc;
    await new Promise((res) => (tmp.onload = res));
    ctx.drawImage(tmp, imgLeft, imgTop, dispW, dispH);

    // convert to blob and upload via existing helper
    canvas.toBlob(async (blob) => {
      try {
        // reuse uploadToCloudinary defined earlier in this file
        const url = await uploadToCloudinary(blob);
        // reuse the same save flow to persist headerImage
        await apiRequest.put(`/users/${user.id}`, { headerImage: url }, { withCredentials: true });
        const updated = { ...user, headerImage: url };
        setUser(updated);
        try { if (typeof updateUser === 'function') updateUser(updated); } catch (e) {}
      } catch (err) {
        console.error('Header upload failed', err);
        setToast({ show: true, message: 'Header upload failed', type: 'error' });
        setTimeout(() => setToast({ show: false, message: '', type: 'info' }), 2000);
      } finally {
        setHeaderEditOpen(false);
        setHeaderEditSrc(null);
      }
    }, 'image/jpeg', 0.92);
  };

  // Fit image to editor stage (useful quick "zoom out")
  const fitToStage = () => {
    const img = editImageRef.current;
    const stage = editorStageRef.current;
    if (!img || !stage) return;
    const stageRect = stage.getBoundingClientRect();
    const stageW = stageRect.width;
    const stageH = stageRect.height;
    const scale = Math.min(stageW / img.naturalWidth, stageH / img.naturalHeight);
    // use a small epsilon and clamp
    const newScale = Math.max(0.01, Math.min(5, scale));
    setEditScale(newScale);
    setEditPos({ x: 0, y: 0 });
  };

  return (
    <div className="profile-shell">
      {/* Full-page centered loading overlay */}
      {loading && (
        <div className="page-loading" role="status" aria-live="polite" aria-label="Loading">
          <div className="page-loading-inner">
            <div className="spinner" aria-hidden="true" />
            <div className="loading-label">{typeof loading === 'string' && loading ? loading : 'Loading‚Ä¶'}</div>
          </div>

          {/* Powered by: LOGO center bottom, "Powered By" under the logo */}
          <div className="powered-by" aria-hidden="true">
            <div className="inner">
              <div className="logo" style={{ fontFamily: 'Mononokiz' }}>
                <div className="logo-text">
                  <span className="need">NEED</span>
                  <span className="for">FOR</span>
                  <span className="drive">DRIVE</span>
                </div>
              </div>
              <div className="powered-by-text">Powered By</div>
            </div>
          </div>
        </div>
      )}

      <header className="profile-header" aria-label="Profile header">
        {/* Exact-size cover container (image cropped to HEADER_W x HEADER_H via CSS object-fit) */}
        <div className="header-img-wrap" aria-hidden={!user.headerImage}>
          {user.headerImage ? (
            <img className="header-img" src={user.headerImage} alt={`${user.username} header`} />
          ) : null}
        </div>
        <div className="header-overlay" />

        <div className="header-actions">
          {/* single Cloudinary widget button for header upload */}
          <UploadWidget
            uwConfig={{
              cloudName: "dqbezy7ge",
              uploadPreset: "4authnfd",
              multiple: false,
              maxImageFileSize: 9000000,
              folder: `users/${user.id}/headers`,
              buttonLabel: 'Change header'
            }}
            setState={onHeaderWidgetState}
          />

          {/* show Adjust only when editing and a header is present */}
          {editing && user.headerImage && (
            <button
              type="button"
              className="upload-widget-btn"
              onClick={() => {
                setHeaderEditSrc(user.headerImage);
                setEditScale(1);
                setEditPos({ x: 0, y: 0 });
                setHeaderEditOpen(true);
              }}
              aria-label="Adjust header image"
            >
              Adjust
            </button>
          )}
        </div>

         <div className="avatar-wrap">
            <div className="avatar-frame">
            <img className="avatar-img" src={user.avatar || '/default-avatar.png'} alt={`${user.username} avatar`} />
            {/* Avatar upload: use the same styled button as header but positioned under the avatar */}
            <div className="avatar-upload-below">
              <UploadWidget
                uwConfig={{
                  cloudName: "dqbezy7ge",
                  uploadPreset: "4authnfd",
                  multiple: false,
                  maxImageFileSize: 9000000,
                  folder: `users/${user.id}/avatars`,
                  buttonLabel: 'Change'
                }}
                setState={onAvatarWidgetState}
              />
            </div>
          </div>
          <div className="user-basic">
            <h2 className="username">{user.username}</h2>
            <div className="meta">
              <span className="role">{user.userType || 'User'}</span>
              <span className="joined">{user.createdAt ? new Date(user.createdAt).toLocaleDateString() : ''}</span>
            </div>
          </div>
        </div>
      </header>

      {/* Header editor modal */}
      {headerEditOpen && (
        <div className="header-editor" onMouseMove={onEditPointerMove} onMouseUp={onEditPointerUp} onTouchMove={onEditPointerMove} onTouchEnd={onEditPointerUp}>
          <div className="editor-panel" onMouseLeave={onEditPointerUp}>
            <div className="editor-stage" ref={editorStageRef} onMouseDown={onEditPointerDown} onTouchStart={onEditPointerDown}>
              <img
                ref={editImageRef}
                src={headerEditSrc}
                alt="Edit header"
                className="editor-image"
                style={{ transform: `translate(${editPos.x}px, ${editPos.y}px) scale(${editScale})` }}
                draggable={false}
              />
            </div>
            <div className="editor-controls">
              <label>Zoom</label>
              {/* wider zoom-out range */}
              <input type="range" min="0.05" max="5" step="0.01" value={editScale} onChange={(e) => setEditScale(Number(e.target.value))} />
              <div style={{ display: 'flex', gap: 8, marginTop: 6 }}>
                <button type="button" className="btn ghost" onClick={fitToStage} title="Zoom out to fit">Fit</button>
                <button type="button" className="btn ghost" onClick={() => setEditScale(s => Math.max(0.01, s - 0.1))} aria-label="Zoom out">‚àí</button>
                <button type="button" className="btn ghost" onClick={() => setEditScale(s => Math.min(5, s + 0.1))} aria-label="Zoom in">+</button>
              </div>
              <div className="editor-actions">
                <button className="btn ghost" onClick={() => { setHeaderEditOpen(false); setHeaderEditSrc(null); }}>Cancel</button>
                <button className="btn primary" onClick={saveEditedHeader}>Save</button>
              </div>
            </div>
          </div>
        </div>
      )}

      <main className="profile-main">
        {/* EDIT MODE: show inputs on left and live preview on right */}
        {editing ? (
          <div className="edit-layout">
            <section className="profile-card edit-form" aria-label="Edit profile form">
              <div className="card-head">
                <h3>Edit profile</h3>
                <div className="actions">
                  <button className="btn cancel" onClick={handleCancel}>Cancel</button>
                  <button className="btn ghost" onClick={() => setShowPreviewDuringEdit(!showPreviewDuringEdit)}>
                    {showPreviewDuringEdit ? 'Hide preview' : 'Show preview'}
                  </button>
                </div>
              </div>
              <div className="profile-grid edit-fields">
                <label className="field">
                  <span>Username</span>
                  <input value={user.username || ''} onChange={handleChange('username')} />
                </label>
                <label className="field">
                  <span>Email</span>
                  <input type="email" value={user.email || ''} onChange={handleChange('email')} />
                </label>
                <label className="field">
                  <span>First name</span>
                  <input value={user.firstName || ''} onChange={handleChange('firstName')} />
                </label>
                <label className="field">
                  <span>Last name</span>
                  <input value={user.lastName || ''} onChange={handleChange('lastName')} />
                </label>
                <label className="field">
                  <span>Phone</span>
                  <input value={user.phone || ''} onChange={handleChange('phone')} />
                </label>
                <label className="field full">
                  <span>Bio</span>
                  <textarea value={user.bio || ''} onChange={handleChange('bio')} rows={4} />
                </label>
              </div>
              <div className="card-actions">
                <button className="btn primary" onClick={handleSave} disabled={loading || avatarUploading || headerUploading}>
                  {loading ? 'Saving‚Ä¶' : 'Save changes'}
                </button>
                <button className="btn ghost" onClick={handleCancel}>Discard</button>
              </div>
            </section>

            {/* Live preview while editing */}
            {showPreviewDuringEdit && (
              <aside className="edit-preview">
                <ProfilePreview u={user} />
              </aside>
            )}
          </div>
        ) : (
          /* VIEW MODE: show profile without inputs */
          <div className="view-layout">
            <ProfilePreview u={user} />
            <div className="view-actions">
              <button className="btn edit" onClick={() => { setEditing(true); setShowPreviewDuringEdit(true); }}>Edit</button>
              <button className="btn danger" onClick={() => { try { logout(); } catch (e) {} }}>Logout</button>
            </div>
          </div>
        )}
      </main>

      {/* <<< NEW: centered toast overlay >>> */}
      {toast.show && (
        <div className={`save-toast ${toast.type === 'error' ? 'error' : 'success'}`} role="status" aria-live="polite">
          {toast.message}
        </div>
      )}
    </div>
  );
}

export default MyProfile;